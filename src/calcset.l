%{
/* calcset.l â€” lexical analyzer for the set-only language (commented)
   Responsibilities:
   - recognize keywords (let, if, DO, ELSE)
   - return tokens for operators and punctuation
   - produce NUMBER tokens only inside set literals
   - produce ID tokens (variable names)
   - set yylval fields for Bison (%union expects id / val)
*/
#include "calcset.tab.h"   /* header generated by bison -d calcset.y */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
%}

%%

"let"               { /* keyword to define a set */ return LET; }
"if"                { /* keyword for conditional */ return IF; }
"DO"                { /* keyword starting the then-branch */ return DO; }
"ELSE"              { /* keyword starting the else-branch */ return ELSE; }

"=="                { return EQ; }
"!="                { return NEQ; }

[0-9]+              { yylval.val = atoi(yytext); return NUMBER; }

[a-zA-Z_][a-zA-Z0-9_]* { yylval.id = strdup(yytext); return ID; } 

"{"                 { return '{'; }
"}"                 { return '}'; }
","                 { return ','; }
"="                 { return '='; }
"("                 { return '('; }
")"                 { return ')'; }
"\n"                { /* end of statement / line */ return '\n'; }
[ \t\r]+            { /* ignore whitespace */ }

"+"                 { return UNION;}  /* union */
"-"                 { return DIFF; }   /* difference */
"^"                 { return INTER; }   /* intersection */
"*"                 { return PROD; } /* Cartesian product operator */

.                   { printf("Unknown character: %s\n", yytext); }

%%


int yywrap() { return 1; }